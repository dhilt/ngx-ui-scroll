<div class="demo">

  <app-demo-title [config]="demoConfig"></app-demo-title>

  <div class="work">
    <div class="viewport-wrapper">
      <div class="viewport-label">common &darr;</div>
      <div class="viewport">
        <div *uiScroll="let item of datasourceCommon">
          <div class="item">{{item.text}}</div>
        </div>
      </div>
    </div>
    <div class="viewport-wrapper">
      <div class="viewport-label">inverted &uarr;</div>
      <div class="viewport">
        <div *uiScroll="let item of datasourceInverted">
          <div class="item">{{item.text}}</div>
        </div>
      </div>
    </div>
    <div class="clearfix mb-3"></div>
  </div>

  <pre class="prettyprint">{{sources[0].text}}</pre>

  <p>
    <em>Datasource.get</em> method implementation could be quite complex and flexible.
    This piece demonstrates how the dataset we want to virtualize could be
    processed to provide "inverted" viewport logic when
    new positive items are retrieved by scrolling up.
  </p>
  <p>
    <em>getData</em> method implements positive limited datasource
    as it was done in the previous sample with only change: left dataset boundary
    is parametrized by <em>MIN</em> property.
    So <em>datasourceCommon.get</em> just passes <em>getData</em> result
    to its <em>success</em> callback.
  </p>
  <p>
    But <em>datasourceInverted.get</em> does the simple math:
    it inverts and shifts the <em>index</em> and reverses the result array.
    So the <em>uiScroll</em> gets some specifically processed portion of our dataset
    that reflects our needs. By settings <em>startIndex</em> value to -10 in this case
    we are telling that we want 10 items to be fetched and rendered
    in forward direction initially. And it does not depend on <em>MIN</em>,
    it does depend on the viewport and single item size: 10 items are visible.
  </p>
</div>

